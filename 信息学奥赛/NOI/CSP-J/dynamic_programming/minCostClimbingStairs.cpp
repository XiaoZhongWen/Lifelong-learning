/*
 * @Author: 肖仲文 xiaozhongwen@mye.hk
 * @Date: 2024-07-23 17:19:40
 * @LastEditors: 肖仲文 xiaozhongwen@mye.hk
 * @LastEditTime: 2024-07-23 17:29:16
 * @FilePath: /CSP-J/dynamic_programming/minCostClimbingStairs.cpp
 * 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。
 * 一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。
 * 请你计算并返回达到楼梯顶部的最低花费。
 */
#include <cstdio>
#include <cstring>

/**
 * 用动态规划算法处理这个问题，不会陷入局部最优解的原因
 * 动态规划算法适用于该问题的原因在于它解决了一个全局最优问题（爬到顶部的最小花费）
 * 而不是局部最优问题（每一级台阶的花费）。
 * 这要归功于问题本身的结构特性：最优子结构和重叠子问题
 * 
 * 最优子结构性质
 * 最优子结构性质意味着一个问题的最优解包含其子问题的最优解。
 * 换句话说，如果你能找到每一步的最优解，那么这些最优解的组合就是整个问题的最优解
 * 到达第 i 级台阶的最小花费等于从第 i-1 级或第 i-2 级台阶过来的最小花费加上当前台阶的花费。
 * dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
 * 由于 dp[i] 的计算仅依赖于 dp[i-1] 和 dp[i-2]
 * 并且这些子问题的解（即 dp[i-1] 和 dp[i-2]）都是最优的
 * 因此整个问题的解 dp[n] 也是最优的。
 * 
 * 重叠子问题性质
 * 重叠子问题性质意味着问题可以分解为许多重复的子问题。
 * 在本例中，每个台阶的最小花费计算都依赖于前面的两个台阶的最小花费，因此会有大量重叠的计算。
 * 动态规划通过存储这些子问题的解（在 dp 数组中）来避免重复计算，从而提高了效率。
 * 
 * 动态规划考虑了整个问题的全局结构，通过逐步构建并保存每个子问题的最优解，最终得到全局最优解。
 * 在这个问题中，每一步的最小花费不仅考虑当前台阶的花费，
 * 还综合考虑了从前一个台阶和前两个台阶过来的最小花费，因此不会陷入局部最优解的陷阱
 */

int minCostClimbingStairs(vector<int>& cost) {
  int n = cost.size();
  // 创建dp数组保存第i级台阶的最小花费
  int dp[n + 1];
  // 初始化dp数组
  memset(dp, 0, sizeof(dp))
  if (n == 0) {
      return 0;
  }
  if (n == 1) {
      return cost[0];
  }
  if (n == 2) {
      return min(cost[0], cost[1]);
  }
  
  // 由于可以选择下标0或1作为初始台阶
  dp[0] = dp[1] = 0;
  
  // 计算各级台阶的最小花费
  for (int i = 2; i <= n; i++) {
      // 第i级台阶的最小花费
      // 由于每次可以跨1或2级台阶
      // 第i级台阶的最小花费等于从第i-1级台阶或第i-2级台阶上来的最小花费
      dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
  }
  return dp[n];
}

int main() {
  return 0;
}